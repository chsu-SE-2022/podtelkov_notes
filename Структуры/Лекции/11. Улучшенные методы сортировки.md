## Шейкерная сортировка (сортировка перемешиванием) 
Данный метод является улучшением метода пузырька:
1) Запоминать были или нет перестановки в процессе некоторого прохода. Если не было, сортировку можно завершить. 
2) Запоминать не только сам факт перестановки, но и место последнего обмена. Ясно что после этого места массив уже отсортирован. 
3) Проводить сортировку последовательно в двух направлениях по массиву. Сначала от конца к началу, от начала к концу. 

```c++
include <iostream>
include <fstream>
using namespce std;

void shaker(int *m, int n){
	int left=1, right=n-1, k=right;
	do{
		for (int j=right; j>=left; j--)
			if (m[j]<m[j-1]){
			swap(m[j],m[j-1]); 
			k=j;}
		left=k+1;
		
		for (int j=left; j=<right; j++)
			if (m[j]>m[j+1]){
			swap(m[j],m[j+1]); 
			k=j;}
		right=k-1;
			
	} while(left<=right)
	
}
void main(){
	cost int n = 10;
	int a[n]={10,4,55,66,4,123,12,666,3,-1};
	shaker(a,n);
	
	for (int i=0; i<0; i++)
		cout << a[i] << " ";
	cout << endl;
	system("pause");
}
```
### Сложность
В лучшем случае на уже отсортированном массиве сложность будет O(n), так как будет выполнен один раз первый цикл for, после чего left = right +1;
Однако в худшем случае (отсортирован в обратном порядке) сложность все равно будет O(n^2).

## Сортировка Шелла
Сначала отдельно группируются и сортируются элементы отстоящие друг от друга на расстоянии n/2. Затем на расстоянии n/4 и так далее, пока не дойдем до обычной одинарной сортировки. На каждом проходе сортировка программируется как сортировка вставками, поэтому если какая-то последовательность уже отсортирована, происходит переход к следующей. 

10, 4, 55, 66, 4, 123, 12, 666
4, 4, 12, 66, 10, 123, 55, 666
4, 4, 10, 66, 12, 123, 55, 666
4, 4, 10, 12, 55, 66, 123, 666

```c++
include <iostream>
include <fstream>
using namespce std;

void shell(int *m, int n){
	int step=n/2;
	while (step>0){ 
	for (int i=0; i<n-step; i++){
		int j=1;
		while (j>=0 && m[j]>m[j+step])
			{swap(m[j], m[j+step]);
			j-=step;
			}
	}
	step/=2;
	}
} 
```

### Сложность
Сортировка дает выигрыш по сравнению с классическими методами, потому что на каждом шаге сортируется либо немного элементов (2, 4, 7), либо элементы уже почти отсортированы. В классической сортировке Шелла расстояние между элементами меняется как кратные четные числа. На самом деле это не лучший вариант. До сих пор окончательно не известно при каких расстояниях в серии скорость сортировки самая быстрая, но точно известно, что они не должны быть множителями друг друга. 
Хороший результат дают серии: 1 4 13 40 121 и так далее
Или 1 3 7 15 31 и так далее. 
При этом сложность метода O(n^1.2)

## Пирамидальная сортировка
Одномерный массив представляется в виде бинарного дерева. 
a[n]={10,4,55,66,4,123,12,666,};
```
			3
		4       55
	66    4  123   12
666
```
Затем все узлы выстраиваются в таком порядке, что никакой родитель не меньше своих потомков. 666 и 66 поменяются местами и тд. В результате такой процедуры в корне дерева (нулевой элемент массива) появляется наибольший элемент. Его мы меняем местами с последним. В результате все элементы дерева находятся на своих местах за исключением нулевого элементу. Его нужно протолкнуть по дереву до требуемого места. После этого в корне дерева вновь окажется максимальный из оставшихся поменяем его местами с предпоследним и так далее. 
### Сложность 
Выстраивание дерева в хорошем виде (когда ни один родитель не меньше своих детей) требует одноразового прохода по всем элементам O(n). В дальнейшем каждый элемент проталкиваем по дереву, затрачивая на это не более n * log2n 
Итог:  O(n log2n) всегда и на любом массиве. 
```c++
void pushDown(int *m, int root, )


```