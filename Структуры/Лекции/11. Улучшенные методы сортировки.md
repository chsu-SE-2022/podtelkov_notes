## Шейкерная сортировка (сортировка перемешиванием) 
Данный метод является улучшением метода пузырька:
1) Запоминать были или нет перестановки в процессе некоторого прохода. Если не было, сортировку можно завершить. 
2) Запоминать не только сам факт перестановки, но и место последнего обмена. Ясно что после этого места массив уже отсортирован. 
3) Проводить сортировку последовательно в двух направлениях по массиву. Сначала от конца к началу, от начала к концу. 

```c++
include <iostream>
include <fstream>
using namespce std;

void shaker(int *m, int n){
	int left=1, right=n-1, k=right;
	do{
		for (int j=right; j>=left; j--)
			if (m[j]<m[j-1]){
			swap(m[j],m[j-1]); 
			k=j;}
		left=k+1;
		
		for (int j=left; j=<right; j++)
			if (m[j]>m[j+1]){
			swap(m[j],m[j+1]); 
			k=j;}
		right=k-1;
			
	} while(left<=right)
	
}
void main(){
	cost int n = 10;
	int a[n]={10,4,55,66,4,123,12,666,3,-1};
	shaker(a,n);
	
	for (int i=0; i<0; i++)
		cout << a[i] << " ";
	cout << endl;
	system("pause");
}
```
### Сложность
В лучшем случае на уже отсортированном массиве сложность будет O(n), так как будет выполнен один раз первый цикл for, после чего left = right +1;
Однако в худшем случае (отсортирован в обратном порядке) сложность все равно будет O(n^2).

## Сортировка Шелла
Сначала отдельно группируются и сортируются элементы отстоящие друг от друга на расстоянии n/2. Затем на расстоянии n/4 и так далее, пока не дойдем до обычной одинарной сортировки. На каждом проходе сортировка программируется как сортировка вставками, поэтому если какая-то последовательность уже отсортирована, происходит переход к следующей. 

10, 4, 55, 66, 4, 123, 12, 666
4, 4, 12, 66, 10, 123, 55, 666
4, 4, 10, 66, 12, 123, 55, 666
4, 4, 10, 12, 55, 66, 123, 666

```c++
include <iostream>
include <fstream>
using namespce std;

void shell(int *m, int n){
	int step=n/2;
	while (step>0){ 
	for (int i=0; i<n-step; i++){
		int j=1;
		while (j>=0 && m[j]>m[j+step])
			{swap(m[j], m[j+step]);
			j-=step;
			}
	}
	step/=2;
	}
} 
```

### Сложность
Сортировка дает выигрыш по сравнению с классическими методами, потому что на каждом шаге сортируется либо немного элементов (2, 4, 7), либо элементы уже почти отсортированы. В классической сортировке Шелла расстояние между элементами меняется как кратные четные числа. На самом деле это не лучший вариант. До сих пор окончательно не известно при каких расстояниях в серии скорость сортировки самая быстрая, но точно известно, что они не должны быть множителями друг друга. 
Хороший результат дают серии: 1 4 13 40 121 и так далее
Или 1 3 7 15 31 и так далее. 
При этом сложность метода O(n^1.2)

## Пирамидальная сортировка
Одномерный массив представляется в виде бинарного дерева. 
a[n]={10,4,55,66,4,123,12,666,};
```
			3
		4       55
	66    4  123   12
666
```
Затем все узлы выстраиваются в таком порядке, что никакой родитель не меньше своих потомков. 666 и 66 поменяются местами и тд. В результате такой процедуры в корне дерева (нулевой элемент массива) появляется наибольший элемент. Его мы меняем местами с последним. В результате все элементы дерева находятся на своих местах за исключением нулевого элементу. Его нужно протолкнуть по дереву до требуемого места. После этого в корне дерева вновь окажется максимальный из оставшихся поменяем его местами с предпоследним и так далее. 
### Сложность 
Выстраивание дерева в хорошем виде (когда ни один родитель не меньше своих детей) требует одноразового прохода по всем элементам O(n). В дальнейшем каждый элемент проталкиваем по дереву, затрачивая на это не более n * log2n 
Итог:  O(n log2n) всегда и на любом массиве. 
```c++
void pushDown(int *m, int root, int bottom){
	int done=0, maxChilde;
	int a[n]={10,4,55,66,4,123,12,666};
	while((root*2+1 <= bottom) && (!done)){
		if (2*root+1 == bootom) maxChilde = 2*root+1;
			else 
		if (m[2*root+1]>m[2*root+1]+2) maxChilde = 2*root+1 //левой потомок больше правого
			else maxChilde = 2*root+2;
		if (m[root]<m[maxChilde]) {
			swap(m[root],[maxChilde]);
			root=maxChild;
		}else done=1; 
	}
}

void heapSort(int *m, int n){
	for (int i=n/2-1, i>=0, i--)
		pushDown(m,i,n-1);
		
	for (int i=n-1, i>=0, i--){
		swap(m[0],m[i]);
		pushDown(m,0,i-1);	
	}
}
```

## Быстрая сортировка
В массиве выбирается так называемый опорный элемент стоящий в его центре (index n/2). После этого все элементы массива переставляются таким образом, что слева оказываются элементы <= опорного, а справа >= опорного. После этого сортировка рекурсивно применяется к левой и правой частям массива и так далее.
Обмен элементами производится следующим образом: слева ищется элемент - не меньше опорного, справа - не больший; меняются местами и так далее. 

```c++
void sort(int *m, int left, int right){
	int i=left, j=right, key=m[(left+right)/2];
	do {
		while (m[i]<key) i++;
		while (m[i]<key) j--;
		if (i<=j) {
			swap(m[i],m[j]);
			i++;
			j--;
		}
	} while (i<=j);
	if (i<right) sort(m,i,right);
	if (j>left) sort(m,left,j);
}
void quickSort(int *m, int n){
	sort(m,0,n-1);
}
```
### Сложность 
Если ключевой элемент выбирается таким образом, что все элементы массива делятся им по значениям "меньше" "больше" ровно по палам, то левая и правая части, относительно ключа, будут одинаковы и количество таких делений логарифм m по основанию 2. При этом на каждом проходе пробегаем по всем элементам O(log n), но в худшем случае, если ключом оказывается минимальный или максимальный элемент, то только он окажется на своем месте, а остальные элементы массива либо справа(если ключ минимальный) от него, либо слева (если ключ максимальный). Сложность будет O(n^2).

## Карманная сортировка
Это единственная сортировка, которая может упорядочить элементы за время O(n), но для этого множество всех возможных значений ключа должно быть ограничено и мы это ограничение должны знатью. 
Для сортировки заводится массив "карманов". Каждый элемент массива (карман) - это указатель на список, в котором расположены объекты с ключом совпадающим с индексом кармана. 