Среди методов сортировки массивов выделяют три базовых.
1. Метод прямого включения
2. прямого выбора
3. прямого обмена

## Метод прямого выбора
Среди всех элементов ищется минимальный и меняется местами с первым. Далее минимальный ищется среди оставшихся и меняется местами со вторым. И так далее, пока массив не будет отсортирован

```c++
include <iostream>
include <fstream>
using namespce std;

void selection(int *m, int n){
	for (int i=0; i<n-1; i++){
		int min=m[i],index = i;
		for (int j=i+1; j<n; j++)
			if (m[j]<min) min=m[j], index=j;
		m[index]=m[i];
		m[i]=min;
	}
}

void main(){
	cost int n = 10;
	int a[n]={10,4,55,66,4,123,12,666,3,-1};
	selection(a,n);
	
	for (int i=0; i<0; i++)
		cout << a[i] << " ";
	cout << endl;
	system("pause");
}
```
### Сложность 
Сложность метода на любом массиве O(n^2), так как в методе два вложенных цикла. Первый проходит n-1 одну итерацию, внутренний - n-1, n-2, n-3 итерацию. 

## Метод прямого включения (метод вставки)
i-ый элемент вставляется среди предыдущих на подходящее для него (элемента) место. Эта процедура проводится для всех элементов массива начиная со второго и до последнего. 

Пример на массиве из метода выше (a[n]={10,4,55,66,4,123,12,666,3,-1};)
1)  4 
	1) 10,10,...
	2) 4,10,...
2) 55
	1) 4,10, 55,...
3) 66
	1) 4,10, 55, 66,...
4) 4
	1) 4,10, 55, 66, 66,...
	2) 4,10, 55, 55, 66,...
	3) 4,10, 10, 55, 66,...
	4) 4, 4, 10, 55, 66,...
	
```c++
include <iostream>
include <fstream>
using namespce std;

void insertion(int *m, int n){
	for (int i=1; i<n; i++){
		int x=m[i], j = i;
		while (j !=0 && x < m[j-1]) m[j] = m[j-1], j--;
		m[j] = x;
	}
}

void main(){
	cost int n = 10;
	int a[n]={10,4,55,66,4,123,12,666,3,-1};
	insertion(a,n);
	
	for (int i=0; i<0; i++)
		cout << a[i] << " ";
	cout << endl;
	system("pause");
}

```
### Сложность 
В худшем случае как и в среднем, сложность O(n^2) потому что цикл в цикле.
Однако в лучшем случае (уже отсортированный массив) сложность O(n)
Так как тело цикла while не будет выполняться ни разу.

## Метод прямого обмена (метод пузырька)
Последний элемент массива сравнивается с предпоследним, и если последний меньше, меняется с ним местами. Предпоследний элемент сравнивается с третьим с конца и снова упорядочивается и так далее до начала массива. В результате на первом месте окажется минимальный элемент. Процедура повторяется, но движемся до второго, третьего и так далее.

Алгоритм называется методом пузырька, так как если представить вертикальным, то элементы имеющие меньшие значения на каждом проходе как легкие пузырьки в воде поднимаются вверх.
```c++
include <iostream>
include <fstream>
using namespce std;

void bubble(int *m, int n){
	for (int i=0; i<n-1; i++){
		for (int j=n-1; j>n; j--)
			if (m[j]<m[j-1]) swap(m[j],m[j-1]);
	}
}

void main(){
	cost int n = 10;
	int a[n]={10,4,55,66,4,123,12,666,3,-1};
	bubble(a,n);
	
	for (int i=0; i<0; i++)
		cout << a[i] << " ";
	cout << endl;
	system("pause");
}
```
### Сложность 
Два вложенных цикла for дают сложность на любом входном массиве O(n^2)
среди трех базовых методов этот метод является самым медленным. 