Среди методов сортировки массивов выделяют три базовых.
1. Метод прямого включения
2. прямого выбора
3. прямого обмена

## Метод прямого выбора
Среди всех элементов ищется минимальный и меняется местами с первым. Далее минимальный ищется среди оставшихся и меняется местами со вторым. И так далее, пока массив не будет отсортирован

```c++
include <iostream>
include <fstream>
using namespce std;

void selection(int *m, int n){
	for (int i=0; i<n-1; i++){
		int min=m[i],index = i;
		for (int j=i+1; j<n; j++)
			if (m[j]<min) min=m[j], index=j;
		m[index]=m[i];
		m[i]=min;
	}
}

void main(){
	cost int n = 10;
	int a[n]={10,4,55,66,4,123,12,666,3,-1};
	selection(a,n);
	
	for (int i=0; i<0; i++)
		cout << a[i] << " ";
	cout << endl;
	system("pause");
}
```
### Сложность 
Сложность метода на любом массиве O(n^2), так как в методе два вложенных цикла. Первый проходит n-1 одну итерацию, внутренний - n-1, n-2, n-3 итерацию. 

## Метод прямого включения (метод вставки)
i-ый элемент вставляется среди предыдущих на подходящее для него (элемента) место. Эта процедура проводится для всех элементов массива начиная со второго и до последнего. 

Пример на массиве из метода выше (a[n]={10,4,55,66,4,123,12,666,3,-1};)
1)  4 
	1) 10,10,...
	2) 4,10,...
2) 55
	1) 4,10, 55,...
3) 66
	1) 4,10, 55, 66,...
4) 4
	1) 4,10, 55, 66, 66,...
	2) 4,10, 55, 55, 66,...
	3) 4,10, 10, 55, 66,...
	4) 4, 4, 10, 55, 66,...
	
```c++
include <iostream>
include <fstream>
using namespce std;

void insertion(int *m, int n){
	for (int i=1; i<n; i++){
		int x=m[i], j = i;
		while (j !=0 && x < m[j-1]) m[j] = m[j-1], j--;
		m[j] = x;
	}
}

void main(){
	cost int n = 10;
	int a[n]={10,4,55,66,4,123,12,666,3,-1};
	insertion(a,n);
	
	for (int i=0; i<0; i++)
		cout << a[i] << " ";
	cout << endl;
	system("pause");
}

```
### Сложность 
В худшем случае как и в среднем, сложность O(n^2) потому что цикл в цикле.
Однако в лучшем случае (уже отсортированный массив) сложность O(n)
Так как тело цикла while не будет выполняться ни разу.